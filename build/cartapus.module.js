function t(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function e(e){var r=0;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(e=function(e,r){if(e){if("string"==typeof e)return t(e,void 0);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?t(e,void 0):void 0}}(e)))return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}};throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(r=e[Symbol.iterator]()).next.bind(r)}function r(){}r.prototype={on:function(t,e,r){var n=this.e||(this.e={});return(n[t]||(n[t]=[])).push({fn:e,ctx:r}),this},once:function(t,e,r){var n=this;function s(){n.off(t,s),e.apply(r,arguments)}return s._=e,this.on(t,s,r)},emit:function(t){for(var e=[].slice.call(arguments,1),r=((this.e||(this.e={}))[t]||[]).slice(),n=0,s=r.length;n<s;n++)r[n].fn.apply(r[n].ctx,e);return this},off:function(t,e){var r=this.e||(this.e={}),n=r[t],s=[];if(n&&e)for(var o=0,i=n.length;o<i;o++)n[o].fn!==e&&n[o].fn._!==e&&s.push(n[o]);return s.length?r[t]=s:delete r[t],this}};var n=r;n.TinyEmitter=r;var s=function(t){var r,n;function s(e){var r;return void 0===e&&(e={}),(r=t.call(this)||this).intersect=r.intersect.bind(function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(r)),r.options=Object.assign({root:null,rootMargin:"0px",threshold:.2,once:!1,events:!1},e),r.createMainObserver(),r.init(),r}n=t,(r=s).prototype=Object.create(n.prototype),r.prototype.constructor=r,r.__proto__=n;var o=s.prototype;return o.createMainObserver=function(){this.observers=[{observer:new IntersectionObserver(this.intersect,this.options),threshold:this.options.threshold,elements:[]}]},o.init=function(){this.getElems(),this.createObservers(),this.observe()},o.getElems=function(){this.elems=this.options.root?this.options.root.querySelectorAll("[data-cartapus]"):document.querySelectorAll("[data-cartapus]")},o.createObservers=function(){for(var t,r=e(this.elems);!(t=r()).done;){var n=t.value;if(n.dataset.cartapusThreshold){for(var s,o=parseFloat(n.dataset.cartapusThreshold),i=!1,a=e(this.observers);!(s=a()).done;){var c=s.value;o===c.threshold&&(i=!0,c.elements.push(n))}if(!i){var h={observer:new IntersectionObserver(this.intersect,Object.assign(this.options,{threshold:o})),threshold:o,elements:[n]};this.observers.push(h)}}else this.observers[0].elements.push(n)}},o.intersect=function(t,e){var r=this;t.forEach(function(t){t.isIntersecting?(t.target.dataset.cartapus="visible",r.options.once&&"false"!==t.target.dataset.cartapusOnce&&e.unobserve(t.target)):t.target.dataset.cartapus="hidden",r.options.events&&r.dispatch(t)})},o.dispatch=function(t){var e={element:t.target,visible:t.isIntersecting,intersection:t},r=new CustomEvent("cartapusintersect",{detail:e});t.target.dispatchEvent(r),this.emit("intersect",e)},o.observe=function(){this.observers.forEach(function(t){t.elements.forEach(function(e){t.observer.observe(e)})})},o.unobserve=function(){this.observers.forEach(function(t){t.elements.forEach(function(e){t.observer.unobserve(e)})})},o.destroy=function(){this.unobserve(),this.observers.forEach(function(t){t.elements=[]})},o.reset=function(){this.destroy(),this.init()},s}(n);export default s;
//# sourceMappingURL=cartapus.module.js.map
